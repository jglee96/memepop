# AGENTS.md — MemePop (Codex Instructions)

이 문서는 Codex가 **MemePop** 웹앱을 일관된 기준으로 설계/구현/리팩터링하도록 돕는 프로젝트 가이드입니다.

---

## 0) Product Goal

MemePop은 **유행하는 밈 템플릿을 “변형/리믹스” 형태로 생성**해주는 웹앱입니다.

- 핵심 사용자 흐름
  1. 밈 선택 (밈별 전용 URL)
  2. 변형 옵션/프롬프트 입력
  3. 결과 생성
  4. 결과 복사 후 외부 플랫폼에 직접 사용 (서비스 내 저장 없음)
- 장기 확장: 밈 외에도 “장난감 페이지(인터랙티브 실험)”를 추가하되, SEO/성능/보안 기준을 동일하게 유지합니다.

완료(Definition of Done):

- SEO/AEO(Answer Engine Optimization) 관점에서 **밈별 랜딩 페이지가 검색/공유에 최적화**되어 있음
- 서버 라우트(BFF)에서 안정적으로 생성/검증/로깅하며, **프롬프트 인젝션/프롬프트 해킹 방어**가 포함됨
- 타입 에러 0, lint 0, 핵심 경로에 대한 최소 테스트 존재

---

## 1) Tech Stack

- Framework: **Next.js (App Router)**
- BFF: **Next.js Route Handlers** (`app/api/**`) 기반
- Language: TypeScript (strict)
- Rendering:
  - 밈별 랜딩은 SSR/SSG 혼합 (요구사항에 따라)
  - 생성 결과/공유 페이지는 캐시/재검증 전략을 설계
- Styling/UI: (프로젝트 기준에 맞춰 기입; 없으면 Tailwind 권장)

### 왜 Next.js + BFF인가

- 클라이언트가 직접 LLM/외부 API를 호출하지 않도록 **서버에서 통제**한다
- 프롬프트/입력 검증, 레이트 리밋, 로깅, 캐시, 보안정책을 **중앙에서 강제**한다

---

## 2) Routing Strategy (밈별 route 분리)

밈은 반드시 **전용 canonical URL**을 가진다.

권장 구조(예시):

- 밈 목록: `/memes`
- 밈 상세/생성 UI: `/m/[slug]`

규칙:

- `[slug]`는 안정적인 식별자(영문 소문자+하이픈)로 고정
- 밈 메타데이터(이름/설명/예시/OG 이미지 규격)는 서버에서 단일 소스로 관리
- 밈 상세 페이지는 반드시:
  - `title`, `meta description`, `canonical`, `robots` 정책을 명시
  - OpenGraph/Twitter 카드 메타를 구성
  - 구조화 데이터(JSON-LD)를 고려(필요 시)

---

## 3) SEO / AEO Requirements (매우 중요)

### 3.1 기본 원칙

- 각 밈 페이지는 검색 의도를 만족하는 텍스트 컨텐츠를 포함한다
  - 밈 의미/사용 맥락
  - 변형 예시(샘플)
  - 입력 가이드(금지/권장)
- 성능 예산을 갖고 최적화한다
  - LCP/CLS/INP를 악화시키는 무거운 클라이언트 로직을 지양
  - 이미지 최적화(Next Image), 폰트 최적화, 코드 스플릿

### 3.2 AEO(Answer Engine Optimization) 관점

- 페이지가 “답”을 제공해야 한다
  - 밈을 어떻게 쓰는지, 어떤 프롬프트가 좋은지, 결과가 어떤 톤인지
- FAQ 섹션 제공
  - 예: “이 밈은 어떤 상황에 쓰나요?”, “이런 표현은 금지되나요?”
- 구조화 데이터(JSON-LD)는 필요 시 도입
  - FAQPage / Article / WebPage 등

### 3.3 OG/공유 최적화

- `/m/[slug]` 랜딩 페이지는 밈 템플릿 대표 OG를 가진다
- 본 서비스는 생성 결과를 서버에 저장하지 않으며, 결과별 permalink를 제공하지 않는다
- 공유는 사용자가 복사한 결과를 외부 플랫폼(SNS 등)에 직접 사용하는 방식으로 설계한다

### 3.4 색인/중복 방지

- 파라미터 기반 페이지를 남발하지 않는다
- 생성 결과는 URL로 생성하지 않으며, 색인 대상이 아니다
- 오직 밈 랜딩(`/m/[slug]`)과 설명형 페이지들만 색인 대상이다

---

## 4) BFF/API Design

### 4.1 API 레이어 원칙

- 클라이언트에서 외부 생성 API/LLM 직접 호출 금지
- 모든 생성은 `app/api/generate/**` 아래 route handler에서 수행
- 입력 검증 → 정책 적용 → 모델 호출 → 출력 검증 → 저장/캐시 → 응답

### 4.2 API 엔드포인트

- `POST /api/generate/:slug`
  - 요청: 사용자 입력(옵션/텍스트)
  - 응답: `{ output: string }`
  - 결과는 서버에 저장하지 않는다

- 결과 조회용 API(`GET /api/result/:resultId`)는 존재하지 않는다

### 4.3 입력 스키마(필수)

- Zod(또는 동등)로 런타임 검증
- 길이 제한(문자수), 허용 문자, 금지 패턴(스팸/URL/코드블록 등)
- slug는 서버의 밈 레지스트리에서만 인정

### 4.4 레이트 리밋/봇 방어(필수)

- IP/세션 기반 레이트 리밋
- 비정상 트래픽 감지(짧은 간격 반복, 동일 프롬프트 반복)
- 필요 시 CAPTCHA/Proof-of-Work 고려

---

## 5) Prompt Injection / Prompt Hacking Defense (최우선)

MemePop은 **LLM을 사용할 가능성이 높으며**, 프롬프트 인젝션은 “기능”이 아니라 “공격”으로 취급한다.

### 5.1 위협 모델(반드시 인지)

- 사용자가 입력으로 시스템/개발자 지시를 무력화하려 시도
- 외부 컨텐츠(웹페이지/문서/링크)를 통해 간접 인젝션 유도
- 모델 출력에 악성 링크/피싱/개인정보 요구를 삽입

### 5.2 방어 원칙

- **모델은 신뢰 경계 밖**: 모델 출력은 항상 검증/정제 후 사용
- **권한 분리**: 시스템/정책 프롬프트는 코드에 고정하고, 사용자 입력은 별도 필드로만 전달
- **도구 호출/함수 호출 사용 시** 허용된 스키마만 수행 (화이트리스트)
- **컨텍스트 최소화**: 사용자/세션/내부정보/비밀값을 프롬프트에 넣지 않는다

### 5.3 구현 체크리스트

- 입력 검증:
  - 최대 길이(예: 200~500자), 금지 토큰(예: "system:", "developer:", "ignore previous", "reveal" 등) 휴리스틱
  - URL 입력은 기본 금지(필요 시 allowlist)
- 프롬프트 구성:
  - 정책/안전 규칙은 코드 상수로 고정
  - 사용자 입력은 `user_input`처럼 명확히 라벨링하여 삽입
  - “지시 우선순위”를 명시하고, 사용자 입력은 절대 정책을 변경할 수 없음을 선언
- 출력 검증:
  - 결과 문자열 길이 제한
  - 금지 컨텐츠(개인정보 요구, 피싱 링크, 실행 가능한 코드 등) 필터
  - HTML/마크다운 렌더링 시 escape 기본
- 저장/공유:
  - 결과는 서버에 저장하지 않는다
  - 사용자는 결과를 복사하여 외부 플랫폼에 사용한다
  - XSS 방지(escape, CSP 고려)

### 5.4 안전 모드(권장)

- 공격 패턴 감지 시:
  - 생성 요청 거절 + 짧은 안내
  - 서버 로그에 이벤트 기록(민감 정보 제외)
  - 반복 시 레이트 리밋 강화

---

## 6) Data Model (Stateless 원칙)

본 서비스는 **사용자 데이터 및 생성 결과를 저장하지 않는다.**

- Meme (밈 레지스트리)
  - `slug`, `title`, `description`, `template`, `examples`, `seo`

- GenerationRequest / GenerationResult는 영구 저장하지 않는다
  - 요청은 서버 메모리 상에서만 처리
  - 응답은 즉시 반환 후 폐기

설계 원칙:

- DB에 사용자 입력/결과 저장 금지
- 로그에는 사용자 원문 입력을 저장하지 않는다 (필요 시 길이/해시만 기록)
- 세션 기반 추적 금지 (단, 레이트 리밋용 일시적 메모리 사용은 허용)

---

## 7) Performance Budget

- 밈 랜딩(`/m/[slug]`)은 가볍게:
  - 클라이언트 JS 최소화
  - 이미지 최적화, 폰트 preload 신중
- 생성 UI는 progressive enhancement:
  - 먼저 페이지 렌더 → 생성은 API 호출로 비동기
- API 응답 타임아웃/재시도 정책:
  - 서버 타임아웃 설정
  - 외부 호출 실패 시 사용자에게 재시도 UX 제공

---

## 8) Coding Conventions

- TypeScript strict 유지
- 서버/클라 경계 준수
  - `app/api/**`에서만 비밀 키 접근
  - 클라이언트 컴포넌트에 서버 전용 코드 유입 금지
- 에러 처리
  - API는 일관된 에러 포맷(JSON)
  - 사용자 메시지 vs 로그 메시지 분리

---

## 9) How Codex Should Work Here

Codex는 작업할 때 아래 순서를 지킨다.

1. 관련 route/도메인 파일을 먼저 탐색하고 현재 동작을 파악
2. 변경 범위를 최소화하여 작은 diff로 구현
3. 입력/출력 검증과 보안 정책을 먼저 반영
4. SEO 메타/OG/캐시 정책까지 포함하여 완료
5. 최소한의 테스트(스키마/유틸/핵심 로직)를 추가

Codex는 다음을 하지 않는다.

- 외부 생성 API 키/비밀 값을 코드/문서에 하드코딩
- 사용자 입력을 그대로 시스템 프롬프트로 합치기
- 검증 없는 HTML/마크다운 렌더링

---

## 10) External Documents Structure

AGENTS.md는 “전역 규칙과 아키텍처 원칙”만 유지한다.

세부 설계는 아래 문서로 분리한다.

- `PLANS.md`
  - 마일스톤/스프린트 단위 실행 계획
  - MVP 범위, Task 목록, Acceptance Criteria

- `docs/memes.md`
  - 밈 레지스트리 스펙
  - slug 규칙
  - Meme 타입 정의
  - 랜딩 페이지 필수 텍스트 블록 가이드

- `docs/security-prompting.md`
  - 입력 검증 규칙
  - 프롬프트 분리 전략
  - 출력 정제 정책
  - 로그 정책 (Stateless 보장)

- `docs/seo.md`
  - SEO/AEO 체크리스트
  - OG/메타 구성 규칙
  - 성능 예산 및 Lighthouse 기준

원칙:

- AGENTS.md는 1,000줄을 넘기지 않는다.
- 구현 세부사항은 반드시 개별 문서로 분리한다.
- Codex는 작업 시작 전 AGENTS.md → 해당 세부 문서 순으로 참조한다.
